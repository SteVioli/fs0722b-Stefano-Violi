<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oggetti</title>
</head>
<body>
<!-- tipi di dato primitivi (stringhe,numeri....) ci√≤ che non √® dato primitivo √® un oggetto 
     contenitore di dati eterogenei che forma una struttura dati unica   -->
     <!-- oggetti -> dati detti propriet√† -> coppie nome/valore ('federico' , 32) -->
                <!-- dentro gli oggetti ci sono funzionalit√† dette metodi -> rappresentati da funzioni -->
    <script>
        var oggettoVuoto = {}; // dichiaro un oggetto vuoto -> questa cosa si chiama notazione letterale -> quella che usa le parentesi graffe
        var persona = {'nome': 'Mario','cognome':'Rossi'} // inserisco delle propriet√†, cio√® delle coppie nome:valore
        console.log("üöÄ ~ file: oggetti.html:18 ~ persona", persona)
        var persona = {nome: 'Mario',cognome: 'Rossi'}// i doppi apici sono opzionali perch√® non contravvengo a nessuna regola di naming
        var persona = {"primo-nome":"Mario", "secondo.nome":Rossi}//contravvengo alle regole di naming , quindi devo usare ""
        // una propriet√† pu√≤ avere come valore, qualcosiasi espressione derivante da un'espressione javascript COMPRESO un altro oggetto
        var persona = {
            nome:"Mario",
            cognome:"Rossi",
            indirizzo:{   //la propriet√† √® a sua volta un oggetto composto da specifiche propriet√†
                via:"Via Roma",
                numero:1,
                cap: 20100
            }
        }
        // mi pongo il problema di come accedere alle propriet√† di un oggetto
        // metodo pi√π comune utilizzare il . il dot notation (oggetto.propriet√†)
        var nome = persona.nome;    //approccio pi√π utilizzato, √® pi√π compatto, familiare con altri linguaggi di programmazione
        var nome = persona["nome"]; //altro approccio -> obbligatorio quando il nome della propriet√† non segue le regole di naming
        // se provo ad accedere ad una propriet√† che non √® definita, non genera un errore, ma mi restituisce undefined!
        var et√† = persona.et√†; //undefined

        //creazione per definizione
        // assegnamo un valore a una propriet√† che non √® definita nel nostro oggetto -> creiamo una nuova propriet√† inizializzandola con un valore
        persona.et√† = 42; // cos√¨ a persona genero et√† che non era definita e gli assegno un valore
        // gli oggetti sono entit√† dinamiche, possono evolvere/modificarsi durante l'esecuzione di uno script -> definizione incrementale
        // l'oggetto avr√† una rappresentazione di base che pu√≤ essere arricchita via via con le propriet√† che vogliamo

        // i metodi rappresentano le attivit√† che un oggetto pu√≤ compiere
        function visualizzaNomeCognome(){ return 'Mario Rossi';} // questa √® una funzione che restituisce una stringa
        persona.nomeCognome = visualizzaNomeCognome;             // assegnamo il nome della funzione a una nuova propriet√† dell' oggetto Persona
        // assegnamo alla propriet√† la funzione tramite il suo nome(non il risultato della chiamata alla funzione)
        // la propriet√† nomeCognome contiene una funzione e quindi √® un metodo
        var nomeCognome = persona.nomeCognome();  // per eseguirlo faccio riferimento ad esso con le () , perch√® √® come una chiamata alla funzione
        //oppure
        persona.nomeCognome = function(){return 'Mario Rossi'} // metodo alternativo per eseguire la funzione

        // questo metodo non √® di grande utilit√† -> perch√® visualizza sempre la stessa stringa anche se cambiassi il valore delle propriet√†
        // un modo per visualizzare correttamente il valore corrente delle propriet√† -> keyword this
        persona.nomeCognome = function(){return this.nome + " " + this.cognome;} // restituisce i valori correnti delle propriet√† 
        


    
    </script>
        
</body>
</html>